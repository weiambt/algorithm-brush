# 



## T1

模拟

```
class Solution:
    def isValid(self, s: str) -> bool:
        mp = ['a','e','i','o','u','A','E','I','O','U']
        n = len(s)
        flag1 = 0
        flag2 = 0
        flag3 = 1
        for x in s:
            if x in mp:
                flag1 = 1
            elif ord(x)>=ord('a') and ord(x)<=ord('z'):
                flag2 = 1
            elif ord(x)>=ord('A') and ord(x)<=ord('Z'):
                flag2 = 1
            elif ord(x)>=ord('0') and ord(x)<=ord('9'):
                pass
            else:
                flag3 = 0
        return n>=3 and flag1==1 and flag2==1 and flag3==1
```



## T2 100275. K 周期字符串需要的最少操作次数

贪心

```
class Solution:
    def minimumOperationsToMakeKPeriodic(self, s: str, k: int) -> int:
        n = len(s)
        i = 0
        cnt = Counter()
        while i<n:
            cnt[s[i:i+k]] += 1
            i+=k
        return n//k - max(cnt.values())
            
```



## T3 100283. 同位字符串连接的最小长度

> 给你一个字符串 `s` ，它由某个字符串 `t` 和它的 **同位字符串** 连接而成。
>
> 请你返回字符串 `t` 的 **最小** 可能长度。
>
> **同位字符串** 指的是重新排列一个单词得到的另外一个字符串，原来字符串中的每个字符在新字符串中都恰好只使用一次。
>
> - `1 <= s.length <= 105`



假二分、真暴力（小优化）

做了好久

```
class Solution:
    def minAnagramLength(self, s: str) -> int:
        def check(sz):
            cnt = Counter()
            for i in range(sz):
                cnt[s[i]] += 1
            i = sz
            while i<n:
                now = Counter()
                for j in range(i,i+sz):
                    now[s[j]] += 1
                    if now[s[j]]>cnt[s[j]]:
                        return False
                i += sz
            
            return True

        n = len(s)
        for i in range(1,n+1):
            if n%i==0 and check(i):
                return i
```



## T4 

8分题，做不了