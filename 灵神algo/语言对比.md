# 语言对比



### 堆

- c++默认是大顶堆，java默认是小顶堆，python默认也是小顶堆

  对于非默认的情况，可以在前面加负号实现，比如默认是小顶堆，那么我们想让大的元素在前面，那么可以把所有元素取反，逻辑上就是大顶了，最后拿出来后也取反就是原来的值了

  - 在python中，堆需要引入模块heapq 。

  ```python
  # 方法1：直接引入模块的函数
  from heapq import heappush 
  pq = []
  heappush(pq,1)
  # 方法2：直接导入整个模块
  import heapq
  pq = []
  heapq.heappush(pq,1)
  ```

  leetcode中上述两种方法都可以，建议用方法1直接写。

### 全排列

- python

  result=itertools.permutations(iterable,r)，

  其中result为对迭代对象处理之后返回的结果，数据类型为'itertools.permutations'，如果需要的话，可以通过list()转化为列表。转化为列表之后的元素的数据类型为元组。元素默认排列顺序为迭代对象字典序上的从小到大

  iterable为需要排列的迭代对象，包括列表、字符串、元组、字典（只对键进行全排列）；

  > 原文链接：https://blog.csdn.net/m0_55320151/article/details/126970507

  ```
  from itertools import permutations
  
  for x in permutations([1,2,3]):
      print(x)
      
      (1, 2, 3)
      (1, 3, 2)
      (2, 1, 3)
      (2, 3, 1)
      (3, 1, 2)
      (3, 2, 1)
  
  ```

  带参数

  ```
  for x in permutations([1,2,3],2):
      print(x)
      (1, 2)
      (1, 3)
      (2, 1)
      (2, 3)
      (3, 1)
      (3, 2)
  ```

  

### 全组合

和全排列api差不多

- python

```
from itertools import combinations

for x in combinations([1,2,3],2):
    print(x)
(1, 2)
(1, 3)
(2, 3)
```

### 十进制转二进制

- python

  方法：bin()函数

  ```
  str(bin(n))[2:]
  ```

  例子：

  ```
          n = 10
          s = str(bin(n))
          print(s) # 输出：0b1010
          s = str(bin(n))[2:] # 输出1010
  ```

### 比大小

- python比大小，如果类型不一致，是不会编译报错的

  ```
  print(4=="4") # False
  ```

### 逻辑运算符在表达式内

逻辑运算符要加括号！

```
1 + (d==2) # 输出2
1 + d==2 # 输出False
```

### 无穷大

- python

  自带的常量inf

- 手写

  0x3f3f3f3f

### gcd函数

- python

  gcd()直接用

- C++

  __gcd()

### 字符映射int

a->0，b->1，c->2,...

- 大多数语言

  'a'-'0'就可以了

- python

  py没有字符类型，所以不能直接减字符串，需要使用ord函数，该函数返回Ascii码

  ```
  x = 'c'
  val = ord(x)-ord('a') # 2
  ```

  - 字符转

### 字符串

- python里字符串append

  ```
  s = []
  s.append('a')
  ..
  return ''.join(s) # 返回字符串
  ```

### 二分

py和c++的很像

- list中的二分

  ```
  vector<int> a
  lower_bound(a,0,n,x)
  ```

  

- 哈希表set中的二分

  ```
  set<int> se
  se.lower_bound(x)
  ```



### 排序

- python不能直接指定区间排序，需要用切片排序

  ```
  my_list = [5, 2, 9, 1, 5, 6]
  
  # 指定要排序的区间的起始和结束索引
  start_index = 2
  end_index = 5
  
  # 切片并排序
  sorted_slice = sorted(my_list[start_index:end_index + 1])
  
  # 将排序后的切片重新放回原列表
  my_list[start_index:end_index + 1] = sorted_slice
  
  print(my_list)
  ```

  